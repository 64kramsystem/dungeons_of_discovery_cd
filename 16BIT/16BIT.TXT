




Appendix D
Porting between Visual C++ 2.0 and Visual C++ 1.5x

All the programs in this book were developed with Visual C++ 
2.0, which runs only under Windows NT or Windows 95 and 
creates 32-bit applications. If you're using Visual C++ 1.5x 
under Windows 3.1x, you can still create the applications 
presented in this book. However, you must change the source 
code to run under a 16-bit environment. In addition, Visual 
C++ 1.5x's Visual Workbench does some things slightly 
different from Visual C++ 2.0. In the sections that follow, 
you'll get tips on building this book's program with Visual 
C++ 1.5x.

Dealing with Pointers

Because a 32-bit application runs in a flat (unsegmented) 
memory space, there's no need to use the far or huge 
keywords when declaring pointers. However, 16-bit 
applications don't enjoy this luxury. If you use the wrong 
types of pointers, you will be unable to address memory 
properly. For example, if you don't declare a pointer to a 
bitmap's image as huge, you may find that when you increment 
the pointer, it wraps around to an offset of 0 before you 
reach the end of the bitmap.

Although there's no room here for a complete discussion of 
pointer types, you should be able to find such a discussion 
in any complete C++ book. You should know, however, that you 
only need to worry about data types and functions that you 
add to the program generated by Visual C++'s AppWizard. That 
is, all data and functions generated by Visual C++ already 
define pointers and return values appropriate to the 
selected memory model.

As an example of changing the listings for use with Visual 
C++ 1.5, I've created a 16-bit version of the CDib class. 
The new class is shown below in listings D.1 and D.2. You 
can also find the listings on this book's CD-ROM, in the 
16BIT directory.

Listing D.1--CDIB.H--The Header File for the 16-bit CDib Class

///////////////////////////////////////////////////////////
// CDIB.H: Header file for the DIB class.
///////////////////////////////////////////////////////////

#ifndef __CDIB_H
#define __CDIB_H

class CDib : public CObject
{
protected:
    LPBITMAPFILEHEADER m_pBmFileHeader;
    LPBITMAPINFO m_pBmInfo;
    LPBITMAPINFOHEADER m_pBmInfoHeader;
    RGBQUAD far* m_pRGBTable;
    BYTE huge* m_pDibBits;
    UINT m_numColors;
    
public:
    CDib(const char far* fileName);
    ~CDib();

    DWORD GetDibSizeImage();
    UINT GetDibWidth();
    UINT GetDibHeight();
    UINT GetDibNumColors();
    LPBITMAPINFOHEADER GetDibInfoHeaderPtr();
    LPBITMAPINFO GetDibInfoPtr();
    LPRGBQUAD GetDibRGBTablePtr();
    BYTE huge* GetDibBitsPtr();

protected:
    void LoadBitmapFile(const char far* fileName);

};

#endif

Listing 4.2--CDIB.CPP--The Implementation File for the 16-bit CDib Class

///////////////////////////////////////////////////////////
// CDIB.C: Implementation file for the DIB class.
///////////////////////////////////////////////////////////

#include "stdafx.h"
#include "cdib.h"
#include "windowsx.h"

///////////////////////////////////////////////////////////
// CDib::CDib()
///////////////////////////////////////////////////////////
CDib::CDib(const char far* fileName)
{
    // Load the bitmap and initialize
    // the class's data members.
    LoadBitmapFile(fileName);
}

///////////////////////////////////////////////////////////
// CDib::~CDib()
///////////////////////////////////////////////////////////
CDib::~CDib()
{
    // Free the memory assigned to the bitmap.
    GlobalFreePtr(m_pBmInfo);
}

///////////////////////////////////////////////////////////
// CDib::LoadBitmapFile()
//
// This function loads a DIB from disk into memory. It
// also initializes the various class data members.
///////////////////////////////////////////////////////////
void CDib::LoadBitmapFile
    (const char far* fileName)
{
    // Construct and open a file object.
    CFile file(fileName, CFile::modeRead);
    
    // Read the bitmap's file header into memory.
    BITMAPFILEHEADER bmFileHeader;
    file.Read((void far*)&bmFileHeader, sizeof(bmFileHeader));

    // Check whether the file is really a bitmap.
    if (bmFileHeader.bfType != 0x4d42)
    {
        AfxMessageBox("Not a bitmap file");
        m_pBmFileHeader = 0;
        m_pBmInfo = 0;
        m_pBmInfoHeader = 0;
        m_pRGBTable = 0;
        m_pDibBits = 0;
        m_numColors = 0;
    }    
    // If the file checks out okay, continue loading.
    else
    {
        // Calculate the size of the DIB, which is the
        // file size minus the size of the file header.
        DWORD fileLength = file.GetLength();    
        DWORD dibSize = fileLength - sizeof(bmFileHeader);

        // Allocate enough memory to fit the bitmap.
        BYTE huge* pDib =
            (BYTE huge*)GlobalAllocPtr(GMEM_MOVEABLE, dibSize);
        
        // Read the bitmap into memory and close the file.
        file.ReadHuge((void far*)pDib, dibSize);
        file.Close();

        // Initialize pointers to the bitmap's BITMAPINFO
        // and BITMAPINFOHEADER structures.
        m_pBmInfo = (LPBITMAPINFO) pDib;
        m_pBmInfoHeader = (LPBITMAPINFOHEADER) pDib;
        
        // Calculate a pointer to the bitmap's color table.
        m_pRGBTable =
            (RGBQUAD far*)(pDib + m_pBmInfoHeader->biSize);

        // Get the number of colors in the bitmap.
        int m_numColors = GetDibNumColors();

        // Calculate the bitmap image's size.
        m_pBmInfoHeader->biSizeImage =
            GetDibSizeImage();
        
        // Make sure the biClrUsed field
        // is initialized properly.
        if (m_pBmInfoHeader->biClrUsed == 0)
            m_pBmInfoHeader->biClrUsed = m_numColors;

        // Calculate a pointer to the bitmap's actual data.
        DWORD clrTableSize = m_numColors * sizeof(RGBQUAD);
        m_pDibBits =
            pDib + m_pBmInfoHeader->biSize + clrTableSize;
    }
}

///////////////////////////////////////////////////////////
// CDib::GetDibSizeImage()
//
// This function calculates and returns the size of the
// bitmap's image in bytes.
///////////////////////////////////////////////////////////
DWORD CDib::GetDibSizeImage()
{
    // If the bitmap's biSizeImage field contains
    // invalid information, calculate the correct size.
    if (m_pBmInfoHeader->biSizeImage == 0)
    {
        // Get the width in bytes of a single row.
        DWORD byteWidth = (DWORD) GetDibWidth();
        
        // Get the height of the bitmap.
        DWORD height = (DWORD) GetDibHeight();
        
        // Multiply the byte width by the number of rows.
        DWORD imageSize = byteWidth * height;
        
        return imageSize;
    }
    // Otherwise, just return the size stored in
    // the BITMAPINFOHEADER structure.
    else
        return m_pBmInfoHeader->biSizeImage;
}

///////////////////////////////////////////////////////////
// CDib::GetDibWidth()
//
// This function returns the width in bytes of a single
// row in the bitmap.
///////////////////////////////////////////////////////////
UINT CDib::GetDibWidth()
{
    return (UINT) m_pBmInfoHeader->biWidth;
}
        
///////////////////////////////////////////////////////////
// CDib::GetDibHeight()
//
// This function returns the bitmap's height in pixels.
///////////////////////////////////////////////////////////
UINT CDib::GetDibHeight()
{
    return (UINT) m_pBmInfoHeader->biHeight;
}
        
///////////////////////////////////////////////////////////
// CDib::GetDibNumColors()
//
// This function returns the number of colors in the
// bitmap.
///////////////////////////////////////////////////////////
UINT CDib::GetDibNumColors()
{
    if ((m_pBmInfoHeader->biClrUsed == 0) &&
          (m_pBmInfoHeader->biBitCount < 9))
        return (1 << m_pBmInfoHeader->biBitCount);
    else
        return (int) m_pBmInfoHeader->biClrUsed;
}
    
///////////////////////////////////////////////////////////
// CDib::GetDibInfoHeaderPtr()
//
// This function returns a pointer to the bitmap's
// BITMAPINFOHEADER structure.
///////////////////////////////////////////////////////////
LPBITMAPINFOHEADER CDib::GetDibInfoHeaderPtr()
{
    return m_pBmInfoHeader;
}

///////////////////////////////////////////////////////////
// CDib::GetDibInfoPtr()
//
// This function returns a pointer to the bitmap's
// BITMAPINFO structure.
///////////////////////////////////////////////////////////
LPBITMAPINFO CDib::GetDibInfoPtr()
{
    return m_pBmInfo;
}

///////////////////////////////////////////////////////////
// CDib::GetDibRGBTablePtr()
//
// This function returns a pointer to the bitmap's
// color table.
///////////////////////////////////////////////////////////
LPRGBQUAD CDib::GetDibRGBTablePtr()
{
    return m_pRGBTable;
}

///////////////////////////////////////////////////////////
// CDib::GetDibBitsPtr()
//
// This function returns a pointer to the bitmap's
// actual image data.
///////////////////////////////////////////////////////////
BYTE huge* CDib::GetDibBitsPtr()
{
    return m_pDibBits;
}

Using Visual C++ 1.5

When creating this book's applications with Visual C++ 1.5x, 
you can generally follow the step-by-step instructions given 
in each chapter. However, you will discover that Visual C++ 
1.5x often works differently than Visual C++ 2.0. The most 
important differences are listed below.

* AppWizard. Although Visual C++ 1.5x's AppWizard creates 
the same type of applications that Visual C++ 2.0 does, 
it looks and operates differently. If you need 
instruction on using AppWizard, please consult your 
Visual C++ documentation.

* AppStudio. AppStudio, too, works differently in Visual 
C++ 1.5x. Moreover, it is not as tightly incorporated 
into the Visual C++ development environment. If you need 
instruction on using AppStudio, please consult your 
Visual C++ documentation.

* ClassWizard. In Visual C++, ClassWizard cannot add 
overloaded functions such as PreCreateWindow() and 
DeleteContents(). You must add these functions "by hand" 
to your code. This means placing function declarations in 
the appropriate header file and the function definitions 
in the matching implementation file.

* Projects. In Visual C++ 1.5x, you add files to projects 
using the Project menu's Edit command. In addition, you 
load project files using the Project menu's Open command. 
You will probably stumble upon other differences between 
the way Visual C++ 1.5x and Visual C++ 2.0 handle 
projects. Consult your Visual C++ documentation for more 
information.

* Library Files. When adding libraries to a Visual C++ 1.5x 
project, you must be sure to select the 16-bit version of 
the library. Specifically, use WING.LIB instead of 
WING32.LIB.

To give you a head start, I created a 16-bit version of the 
WINGEX sample program from chapter 4. That program is shown 
in listings D.3 through D.6.  In these listings, code that 
you must add manually is shown between double lines of slash 
characters. Code that you add using ClassWizard is listed 
normally[md]that is, it is not shown between double lines of 
slash characters. Files that were created by AppWizard, but 
which you need not modify, are not shown here. If you'd like 
to know what the unlisted files contain, load them from disk 
using Visual C++ or some other text editor. The full program 
can be found on this book's CD-ROM in the 16BIT\WINGEX16 
directory.

Listing D.3--MAINFRM.H--The Header File for the 16-bit CMainFrame Class

// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs);

    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

// Attributes
public:

// Operations
public:

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

Listing D.4--MAINFRM.CPP--The Implementation File for the 16-bit CMainFrame Class

// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "wingex.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
}

CMainFrame::~CMainFrame()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

///////////////////////////////////////
///////////////////////////////////////
// START CUSTOM CODE
///////////////////////////////////////
///////////////////////////////////////

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // Call base class's version.
    CFrameWnd::PreCreateWindow(cs);
    
    // Set the main window's width and height.
    cs.cx = 350;
    cs.cy = 385;

    return TRUE;
}

///////////////////////////////////////
///////////////////////////////////////
// END CUSTOM CODE
///////////////////////////////////////
///////////////////////////////////////

Listing D.5--WINGEVW.H--The Header File for the 16-bit CWingexView Class

// wingevw.h : interface of the CWingexView class
//
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
///////////////////////////////////////
// START CUSTOM CODE
///////////////////////////////////////
///////////////////////////////////////

#include "c:\wing\include\wing.h"
#include "cdib.h"

typedef struct BmInfo
{
    BITMAPINFOHEADER Header;
    RGBQUAD aColors[256];
} BmInfo;

const WINGDIBWIDTH = 300;
const WINGDIBHEIGHT = 300;

///////////////////////////////////////
///////////////////////////////////////
// END CUSTOM CODE
///////////////////////////////////////
///////////////////////////////////////

class CWingexView : public CView
{
protected: // create from serialization only
    CWingexView();
    DECLARE_DYNCREATE(CWingexView)

// Attributes
public:
    CWingexDoc* GetDocument();

    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    protected:
        HBITMAP m_hOldBitmap;
        HDC m_hWinGDC;
        BmInfo m_WinGBmInfo;
        void huge* m_pWinGDibBits;
        LONG m_orientation;
        HPALETTE m_hPalette;
        CDib* m_pSceneDib;
        CDib* m_pPropDib;
        UINT m_frameNum;
        
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

// Operations
public:

// Implementation
public:
    virtual ~CWingexView();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    void CreateWinGDibPalette();
    //void CopyDIBToWinG(BYTE huge* m_pWinGBmBits, CDib* pDib);
    void CreateIdentityPalette(BmInfo* winGBmInfo,
        CDib* pDib);
    void CopyDIBToWinG(BYTE huge* m_pWinGBmBits,
        UINT dstX, UINT dstY, CDib* pDib,
        UINT frmX, UINT frmY, UINT frmW, UINT frmH);
    void CopyDIBToWinGTrns(BYTE huge* m_pWinGBmBits,
        UINT dstX, UINT dstY, CDib* pDib,
        UINT frmX, UINT frmY, UINT frmW, UINT frmH,
        UINT trnsColor);

    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

// Generated message map functions
protected:
    //{{AFX_MSG(CWingexView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    afx_msg void OnTimer(UINT nIDEvent);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in wingevw.cpp
inline CWingexDoc* CWingexView::GetDocument()
   { return (CWingexDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

Listing D.6--WINGEVW.CPP--The Implementation File for the 16-bit CWingexView Class

// wingevw.cpp : implementation of the CWingexView class
//

#include "stdafx.h"
#include "wingex.h"

#include "wingedoc.h"
#include "wingevw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWingexView

IMPLEMENT_DYNCREATE(CWingexView, CView)

BEGIN_MESSAGE_MAP(CWingexView, CView)
    //{{AFX_MSG_MAP(CWingexView)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWingexView construction/destruction

CWingexView::CWingexView()
{
    // TODO: add construction code here

    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    // Load the SCENE.BMP file.
    m_pSceneDib = new CDib("scene.bmp");
    
    // Load the bitmap containing the animation frames.
    m_pPropDib = new CDib("prop.bmp");
    
    // Check what type of DIB we should use.
    WinGRecommendDIBFormat((BITMAPINFO*)&m_WinGBmInfo);

    // Save the recommended orientation.
    m_orientation = m_WinGBmInfo.Header.biHeight;

    // Fill in the BITMAPINFO structure with values
    // to create a 256-color 300x300 WinG bitmap.
    m_WinGBmInfo.Header.biBitCount = 8;
    m_WinGBmInfo.Header.biCompression = BI_RGB;
    //m_WinGBmInfo.Header.biWidth = 300;
    //m_WinGBmInfo.Header.biHeight = 300 * m_orientation;
    m_WinGBmInfo.Header.biWidth = WINGDIBWIDTH;
    m_WinGBmInfo.Header.biHeight =
        WINGDIBHEIGHT * m_orientation;

    // Copy the screen colors into the WinG bitmap
    // and create a logical palette.
    //CreateWinGDibPalette();
    
    // Create an identity palette based on the
    // CDib object's 256-color palette.
    CreateIdentityPalette(&m_WinGBmInfo, m_pSceneDib);
    
    // Create a WinG device context.
    m_hWinGDC = WinGCreateDC();
    
    // Create a WinG bitmap compatible with the WinG DC.
    HBITMAP hBitmap = WinGCreateBitmap(m_hWinGDC,
        (LPBITMAPINFO)&m_WinGBmInfo,
        (void far* far*)&m_pWinGDibBits);

    // Select the WinG bitmap into the WinG DC.
    m_hOldBitmap =
        (HBITMAP)SelectObject(m_hWinGDC, hBitmap);

    // Clear the garbage from the WinG bitmap.
    PatBlt(m_hWinGDC, 0, 0, 300, 300, BLACKNESS);
    
    // Copy the scene to the WinG bitmap.
    //CopyDIBToWinG((BYTE huge*)m_pWinGDibBits, m_pSceneDib);    
    CopyDIBToWinG((BYTE huge*)m_pWinGDibBits, 0, 0,
        m_pSceneDib, 0, 0, 300, 300);
        
    // Initialize the frame counter.
    m_frameNum = 0;
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////
}

CWingexView::~CWingexView()
{
    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    // Select the old bitmap back into the WinG DC.
    HBITMAP hBitmap =
        (HBITMAP)SelectObject(m_hWinGDC, m_hOldBitmap);

    // Delete the WinG bitmap that the program created.
    DeleteObject(hBitmap);

    // Delete the WinG DC.
    DeleteDC(m_hWinGDC);

    // Delete the logical palette.
    DeleteObject(m_hPalette);
    
    // Delete the CDib object holding SCENE.BMP.
    delete m_pSceneDib;
    
    // Delete the CDib object holding PROP.BMP.
    delete m_pPropDib;
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////
}

/////////////////////////////////////////////////////////////////////////////
// CWingexView drawing

void CWingexView::OnDraw(CDC* pDC)
{
    CWingexDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    // Select the logical palette into the window's DC.
    SelectPalette(pDC->m_hDC, m_hPalette, FALSE);

    // Tell Windows to remap the system palette with
    // the program's logical palette.
    RealizePalette(pDC->m_hDC);

    // Draw a rectangle on the WinG bitmap.
    //Rectangle(m_hWinGDC, 20, 20, 100, 100);

    // Transfer the WinG bitmap to the window's display.
    WinGBitBlt(pDC->m_hDC, 20, 20, 300, 300, m_hWinGDC, 0, 0);
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

}

/////////////////////////////////////////////////////////////////////////////
// CWingexView diagnostics

#ifdef _DEBUG
void CWingexView::AssertValid() const
{
    CView::AssertValid();
}

void CWingexView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CWingexDoc* CWingexView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWingexDoc)));
    return (CWingexDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWingexView message handlers

///////////////////////////////////////
///////////////////////////////////////
// START CUSTOM CODE
///////////////////////////////////////
///////////////////////////////////////

void CWingexView::CreateWinGDibPalette()
{
    // Define a structure for the logical palette.
    struct
    {
        WORD Version;
        WORD NumberOfEntries;
        PALETTEENTRY aEntries[256];
    } logicalPalette = { 0x300, 256 };

    // Get a device context for the screen.
    HDC hScreenDC = ::GetDC(0);

    // Load the system palette into the
    // logical palette structure.
    GetSystemPaletteEntries
        (hScreenDC, 0, 256, logicalPalette.aEntries);

    // Get rid of the screen DC.
    ::ReleaseDC(0, hScreenDC);

    // Copy the system colors into the WinG bitmap's
    // color table and set the appropriate flags.
    for(int i = 0;i < 256;i++)
    {
        m_WinGBmInfo.aColors[i].rgbRed =
            logicalPalette.aEntries[i].peRed;
        m_WinGBmInfo.aColors[i].rgbGreen =
            logicalPalette.aEntries[i].peGreen;
        m_WinGBmInfo.aColors[i].rgbBlue =
            logicalPalette.aEntries[i].peBlue;
        m_WinGBmInfo.aColors[i].rgbReserved = 0;

        logicalPalette.aEntries[i].peFlags = 0;
    }

    // Create the program's logical palette.
    m_hPalette =
        CreatePalette((LOGPALETTE*)&logicalPalette);
}

/*
void CWingexView::CopyDIBToWinG
    (BYTE huge* m_pWinGDibBits, CDib* pDib)
{
    // Get the bitmap's width and height.
    UINT srcWidth = pDib->GetDibWidth();
    UINT srcHeight = pDib->GetDibHeight();

     // Get a pointer to the image's data.
    BYTE huge* pDibBits = pDib->GetDibBitsPtr();

    // Copy data from the source bitmap to the WinG bitmap.
    for (UINT row=0; row<srcHeight; ++row)
        for (UINT col=0; col<srcWidth; ++col)
        {
            LONG index = (LONG)row * (LONG)srcWidth + col;   
            m_pWinGDibBits[index] = pDibBits[index];
        }
} 
*/

void CWingexView::CopyDIBToWinG
    (BYTE huge* m_pWinGDibBits, UINT dstX, UINT dstY,
     CDib* pDib, UINT frmX, UINT frmY, UINT frmW, UINT frmH)
{
    // Get the bitmap's width and height.
    DWORD srcWidth = pDib->GetDibWidth();
    DWORD srcHeight = pDib->GetDibHeight();

     // Get a pointer to the image's data.
    BYTE huge* pDibBits = pDib->GetDibBitsPtr();

    // Copy data from the source bitmap to the WinG bitmap.
    for (UINT row=0; row<frmH; ++row)
        for (UINT col=0; col<frmW; ++col)
        {
            DWORD newSrcY = srcHeight - frmH - frmY + row;
            if (m_orientation == -1)
                newSrcY = srcHeight - row - frmY - 1;
            DWORD srcIndex =
                newSrcY * srcWidth + col + frmX;
            DWORD newDstY =
                WINGDIBHEIGHT - frmH - dstY + row;
            if (m_orientation == -1)
                newDstY = row + dstY;
            DWORD dstIndex =
                newDstY * WINGDIBWIDTH + col + dstX;
            m_pWinGDibBits[dstIndex] = pDibBits[srcIndex];
        }
}

void CWingexView::CreateIdentityPalette
    (BmInfo* winGBmInfo, CDib* pDib)
{
    struct
    {
        WORD Version;
        WORD NumberOfEntries;
        PALETTEENTRY aEntries[256];
    } logicalPalette = {0x300, 256};

     // Get the screen DC.
    HDC Screen = ::GetDC(0);

     // Copy Windows' 20 standard system colors
     // into the new logical palette.
    GetSystemPaletteEntries
        (Screen, 0, 10, logicalPalette.aEntries);
    GetSystemPaletteEntries
        (Screen, 246, 10, logicalPalette.aEntries + 246);

      // Get rid of the screen DC.
    ::ReleaseDC(0,Screen);

      // Copy the standard 20 system colors into
      // the WinG bitmap's color table.
    for(int i = 0; i < 10; i++)
    {
        winGBmInfo->aColors[i].rgbRed =
            logicalPalette.aEntries[i].peRed;
        winGBmInfo->aColors[i].rgbGreen =
            logicalPalette.aEntries[i].peGreen;
        winGBmInfo->aColors[i].rgbBlue =
            logicalPalette.aEntries[i].peBlue;
        winGBmInfo->aColors[i].rgbReserved = 0;

        logicalPalette.aEntries[i].peFlags = 0;

        winGBmInfo->aColors[i + 246].rgbRed =
            logicalPalette.aEntries[i + 246].peRed;
        winGBmInfo->aColors[i + 246].rgbGreen =
            logicalPalette.aEntries[i + 246].peGreen;
        winGBmInfo->aColors[i + 246].rgbBlue =
            logicalPalette.aEntries[i + 246].peBlue;
        winGBmInfo->aColors[i + 246].rgbReserved = 0;

        logicalPalette.aEntries[i + 246].peFlags = 0;
    }

    // Get a pointer to the source bitmap's color table.
    LPRGBQUAD pColorTable = pDib->GetDibRGBTablePtr();

      // Copy the source bitmap's color table into both
      // the WinG bitmap color table and
      // into the new logical palette.
    for(i = 10; i < 246; i++)
    {
        winGBmInfo->aColors[i].rgbRed =
            logicalPalette.aEntries[i].peRed =
            pColorTable[i].rgbRed;
        winGBmInfo->aColors[i].rgbGreen =
            logicalPalette.aEntries[i].peGreen =
            pColorTable[i].rgbGreen;
        winGBmInfo->aColors[i].rgbBlue =
            logicalPalette.aEntries[i].peBlue =
            pColorTable[i].rgbBlue;
        winGBmInfo->aColors[i].rgbReserved = 0;
            logicalPalette.aEntries[i].peFlags =
               PC_NOCOLLAPSE;
    }

     // Create the logical palette.
    m_hPalette =
        CreatePalette((LOGPALETTE*)&logicalPalette);
}

void CWingexView::CopyDIBToWinGTrns
    (BYTE huge* m_pWinGDibBits, UINT dstX, UINT dstY,
     CDib* pDib, UINT frmX, UINT frmY, UINT frmW, UINT frmH,
     UINT trnsColor)
{
    // Get the bitmap's width and height.
    DWORD srcWidth = pDib->GetDibWidth();
    DWORD srcHeight = pDib->GetDibHeight();

     // Get a pointer to the image's data.
    BYTE huge* pDibBits = pDib->GetDibBitsPtr();

    // Copy data from the source bitmap to the WinG bitmap.
    for (UINT row=0; row<frmH; ++row)
        for (UINT col=0; col<frmW; ++col)
        {
            DWORD newSrcY = srcHeight - frmH - frmY + row;
            if (m_orientation == -1)
                newSrcY = srcHeight - row - frmY - 1;
            DWORD srcIndex =
                newSrcY * srcWidth + col + frmX;
            DWORD newDstY =
                WINGDIBHEIGHT - frmH - dstY + row;
            if (m_orientation == -1)
                newDstY = row + dstY;
            DWORD dstIndex =
                newDstY * WINGDIBWIDTH + col + dstX;
            if (pDibBits[srcIndex] != trnsColor)
                m_pWinGDibBits[dstIndex] = pDibBits[srcIndex];
        }
}

///////////////////////////////////////
///////////////////////////////////////
// END CUSTOM CODE
///////////////////////////////////////
///////////////////////////////////////


int CWingexView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    // TODO: Add your specialized creation code here
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    // Start a Windows timer.
    SetTimer(1, 100, 0);
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    return 0;
}

void CWingexView::OnDestroy()
{
    CView::OnDestroy();
    
    // TODO: Add your message handler code here
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    // Destroy the Windows timer.
    KillTimer(1);
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////
}

void CWingexView::OnTimer(UINT nIDEvent)
{
    // TODO: Add your message handler code here and/or call default
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // START CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    // Increment the animation frame counter.
    m_frameNum += 1;
    if (m_frameNum > 7)
        m_frameNum = 0;

    UINT x, y;

    // Get the coordinates for the next frame.
    switch (m_frameNum)
    {
        case 0: x = 1;   y = 1; break;
        case 1: x = 163; y = 1; break;
        case 2: x = 325; y = 1; break;
        case 3: x = 1;   y = 163; break;
        case 4: x = 163; y = 163; break;
        case 5: x = 325; y = 163; break;
        case 6: x = 1;   y = 325; break;
        case 7: x = 163; y = 325;
    }

    // Update the WinG bitmap, by restoring the scene
    // where the last frame appeared and then
    // copying the new frame to the WinG bitmap.
    CopyDIBToWinG((BYTE huge*)m_pWinGDibBits, 70, 70,
        m_pSceneDib, 70, 70, 230, 230);
    CopyDIBToWinGTrns((BYTE huge*)m_pWinGDibBits, 70, 70,
        m_pPropDib, x, y, 160, 160, 255);

    // Get a device context for the window's client area.
    CDC* pClientDC = new CClientDC(this);

    // Select the logical palette into the window's DC.
    SelectPalette(pClientDC->m_hDC, m_hPalette, FALSE);

    // Tell Windows to remap the system palette with
    // the program's logical palette.
    RealizePalette(pClientDC->m_hDC);

    // Transfer the WinG bitmap to the window's display.
    WinGBitBlt(pClientDC->m_hDC, 20, 20, WINGDIBWIDTH,
        WINGDIBHEIGHT, m_hWinGDC, 0, 0);

    // Delete the window's DC.
    delete pClientDC;
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    // END CUSTOM CODE
    ///////////////////////////////////////
    ///////////////////////////////////////

    CView::OnTimer(nIDEvent);
}

Dungeons of Discovery	Appendix B	WING_BLC.DOC 	B-16



